"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PAGE_MAPPING = exports.MOST_USED_FONT = exports.MOST_USED_DISTANCE = exports.MOST_USED_HEIGHT = exports.MAX_HEIGHT = exports.MAX_Y = exports.MIN_Y = exports.MAX_X = exports.MIN_X = void 0;
const ItemTransformer_1 = require("./ItemTransformer");
const GlobalDefinition_1 = require("../GlobalDefinition");
const PageMapping_1 = require("../PageMapping");
const PageFactorFinder_1 = require("../support/PageFactorFinder");
const groupingUtils_1 = require("../support/groupingUtils");
const functional_1 = require("../support/functional");
const stringFunctions_1 = require("../support/stringFunctions");
const simple_statistics_1 = require("simple-statistics");
exports.MIN_X = new GlobalDefinition_1.default('minX');
exports.MAX_X = new GlobalDefinition_1.default('maxX');
exports.MIN_Y = new GlobalDefinition_1.default('minY');
exports.MAX_Y = new GlobalDefinition_1.default('maxY');
exports.MAX_HEIGHT = new GlobalDefinition_1.default('maxHeight');
exports.MOST_USED_HEIGHT = new GlobalDefinition_1.default('mostUsedHeight');
exports.MOST_USED_DISTANCE = new GlobalDefinition_1.default('mostUsedDistance');
exports.MOST_USED_FONT = new GlobalDefinition_1.default('mostUsedFont');
exports.PAGE_MAPPING = new GlobalDefinition_1.default('pageMapping');
const config = {
    // how much distance to min/max/x/y can an item have in order to be considered fringe
    maxDistanceToFringe: 50,
};
function to2DigitDecimalFromString(value) {
    return parseFloat(parseFloat(value).toFixed(2));
}
function to2DigitDecimal(value) {
    return parseFloat(value.toFixed(2));
}
class CalculateStatistics extends ItemTransformer_1.default {
    constructor() {
        super('Calculate Statistics', 'Calculate global statistics that are used in downstream transformers', {
            requireColumns: ['str', 'fontName', 'y', 'height'],
            producesGlobels: [
                exports.MIN_X.key, //TODO
                exports.MOST_USED_HEIGHT.key,
                exports.MOST_USED_FONT.key,
                exports.MOST_USED_DISTANCE.key,
                exports.MAX_HEIGHT.key,
                'fontToFormats',
            ],
            debug: {
                showAll: true,
            },
        });
    }
    transform(context, items) {
        // www.30secondsofcode.org/js/s/frequencies
        // www.30secondsofcode.org/js/s/group-by
        // TODO
        // filter out title pages
        // filter out <= most used keys + x = 3
        // ckmeans(6)
        const heights = items.map((item) => item.data['height']);
        const mostUsedByMedian = (0, simple_statistics_1.median)(heights);
        const heightToOccurrence = {};
        const fontToOccurrence = {};
        let maxHeight = 0;
        // let maxHeightFont: string;
        let minX = 999;
        let maxX = 0;
        let minY = 999;
        let maxY = 0;
        items.forEach((item) => {
            const itemHeight = item.data['height'];
            const itemFont = item.data['fontName'];
            const x = item.data['x'];
            const y = item.data['y'];
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
            heightToOccurrence[itemHeight] = heightToOccurrence[itemHeight] ? heightToOccurrence[itemHeight] + 1 : 1;
            fontToOccurrence[itemFont] = fontToOccurrence[itemFont] ? fontToOccurrence[itemFont] + 1 : 1;
            if (itemHeight > maxHeight) {
                maxHeight = itemHeight;
                // maxHeightFont = itemFont;
            }
        });
        const mostUsedHeight = to2DigitDecimalFromString(getMostUsedKey(heightToOccurrence));
        const mostUsedFont = getMostUsedKey(fontToOccurrence);
        const groupedByPage = (0, groupingUtils_1.groupByPage)(items);
        const pageMapping = parsePageMapping(groupedByPage, minX, maxX, minY, maxY);
        // Parse line distances
        const distanceToOccurrence = {};
        let page = -1;
        let lastItemOfMostUsedHeight;
        items.forEach((item) => {
            if (item.page !== page)
                lastItemOfMostUsedHeight = undefined;
            const itemHeight = to2DigitDecimalFromString(item.data['height']);
            const itemText = item.data['str'];
            const itemY = item.data['y'];
            if (itemHeight == mostUsedHeight && itemText.trim().length > 0) {
                if (lastItemOfMostUsedHeight && itemY != lastItemOfMostUsedHeight.data['y']) {
                    const distance = to2DigitDecimal(lastItemOfMostUsedHeight.data['y'] - itemY);
                    if (distance > 0) {
                        distanceToOccurrence[distance] = distanceToOccurrence[distance] ? distanceToOccurrence[distance] + 1 : 1;
                    }
                }
                lastItemOfMostUsedHeight = item;
            }
            else {
                lastItemOfMostUsedHeight = undefined;
            }
            page = item.page;
        });
        const mostUsedDistance = to2DigitDecimalFromString(getMostUsedKey(distanceToOccurrence));
        const mostUsedFontObject = context.fontMap.get(mostUsedFont);
        return {
            items: items,
            globals: [
                exports.MAX_HEIGHT.value(maxHeight),
                exports.MOST_USED_HEIGHT.value(mostUsedByMedian),
                exports.MOST_USED_DISTANCE.value(mostUsedDistance),
                exports.MOST_USED_FONT.value((mostUsedFontObject === null || mostUsedFontObject === void 0 ? void 0 : mostUsedFontObject.name) || mostUsedFont),
                exports.MIN_X.value(minX),
                exports.MAX_X.value(maxX),
                exports.MIN_Y.value(minY),
                exports.MAX_Y.value(maxY),
                exports.PAGE_MAPPING.value(pageMapping),
            ],
            // globals2: {
            //   mostUsedHeight: mostUsedHeight,
            //   mostUsedFont: mostUsedFont,
            //   mostUsedDistance: mostUsedDistance,
            //   maxHeightFont: maxHeightFont,
            //   fontToFormats: fontToType,
            // },
            messages: [
                'Items per height: ' + JSON.stringify(heightToOccurrence),
                'Items per font: ' + JSON.stringify(fontToOccurrence),
                'Items per distance: ' + JSON.stringify(distanceToOccurrence),
            ],
        };
    }
}
exports.default = CalculateStatistics;
function parsePageMapping(groupedByPage, minX, maxX, minY, maxY) {
    const pageFactor = new PageFactorFinder_1.default().find(groupedByPage, (items) => ({
        index: items[0].page,
        numbers: possiblePageNumbers(items.filter((item) => {
            const x = item.data['x'];
            const y = item.data['y'];
            return (x <= minX + config.maxDistanceToFringe ||
                x >= maxX - config.maxDistanceToFringe ||
                y <= minY + config.maxDistanceToFringe ||
                y >= maxY - config.maxDistanceToFringe);
        })),
    }), { sampleCount: 20, minFulfillment: 0.8 });
    return typeof pageFactor === 'undefined' ? new PageMapping_1.default() : new PageMapping_1.default(pageFactor, true);
}
function getMostUsedKey(keyToOccurrence) {
    let maxOccurence = 0;
    let maxKey = '';
    Object.keys(keyToOccurrence).map((element) => {
        if (!maxKey || keyToOccurrence[element] > maxOccurence) {
            maxOccurence = keyToOccurrence[element];
            maxKey = element;
        }
    });
    return maxKey;
}
function possiblePageNumbers(items) {
    return (0, functional_1.flatten)(items.map((item) => {
        return ((0, stringFunctions_1.extractNumbers)(item.data['str'])
            .filter((number) => number >= 0)
            // .filter((number) => number <= line.page + 1)
            .filter(groupingUtils_1.onlyUniques));
    }));
}
