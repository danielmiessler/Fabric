"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transform = exports.verifyRequiredColumns = exports.convert = exports.parseAndTransform = void 0;
const Globals_1 = require("./Globals");
const ParseProgressReporter_1 = require("./ParseProgressReporter");
const assert_1 = require("./assert");
const TransformContext_1 = require("./transformer/TransformContext");
const defaultOptions = {
    debug: false,
    progressListener: () => { },
};
function parseAndTransform(src, parser, transformers, progressListener) {
    return __awaiter(this, void 0, void 0, function* () {
        const parseResult = yield parseAndVerifyTransformers(src, parser, transformers, progressListener);
        const transformedItems = transform(parseResult, transformers);
        return Promise.resolve({
            convert: (converter) => converter.convert(transformedItems),
        });
    });
}
exports.parseAndTransform = parseAndTransform;
function convert(src_1, parser_1, transformers_1, converter_1) {
    return __awaiter(this, arguments, void 0, function* (src, parser, transformers, converter, options = defaultOptions) {
        // parse
        const parseResult = yield parser.parse(src, new ParseProgressReporter_1.default(options.progressListener));
        verifyRequiredColumns(parseResult.schema, transformers);
        // transform
        let items = parseResult.items;
        let globals = new Globals_1.default();
        const context = new TransformContext_1.default(parseResult.fontMap, parseResult.pageViewports, globals);
        transformers.forEach((transformer) => {
            const result = transformer.transform(context, items);
            globals = globals.withValues(result.globals);
            items = result.items;
        });
        // convert
        return converter.convert(items);
    });
}
exports.convert = convert;
function parseAndVerifyTransformers(src, parser, transformers, progressListener) {
    return __awaiter(this, void 0, void 0, function* () {
        return parser.parse(src, new ParseProgressReporter_1.default(progressListener)).then((parseResult) => {
            verifyRequiredColumns(parseResult.schema, transformers);
            return parseResult;
        });
    });
}
/**
 * Goes through all transformer and makes sure each required column is available in its predecessor schema.
 *
 * @param inputSchema
 * @param transformers
 */
function verifyRequiredColumns(inputSchema, transformers) {
    var _a;
    const schemas = [inputSchema];
    for (let idx = 0; idx < transformers.length; idx++) {
        const transformer = transformers[idx];
        const predecessorSchema = schemas[idx];
        (_a = transformer.descriptor.requireColumns) === null || _a === void 0 ? void 0 : _a.forEach((column) => {
            (0, assert_1.assert)(predecessorSchema.includes(column), `Input schema [${predecessorSchema.join(', ')}] for transformer '${transformer.name}' does not contain the required column '${column}'`);
        });
        const outputSchema = transformer.schemaTransformer(predecessorSchema);
        schemas.push(outputSchema);
    }
}
exports.verifyRequiredColumns = verifyRequiredColumns;
function transform(parseResult, transformers) {
    let items = parseResult.items;
    let globals = new Globals_1.default();
    const context = new TransformContext_1.default(parseResult.fontMap, parseResult.pageViewports, globals);
    transformers.forEach((transformer) => {
        const result = transformer.transform(context, items);
        globals = globals.withValues(result.globals);
        items = result.items;
    });
    return items;
}
exports.transform = transform;
